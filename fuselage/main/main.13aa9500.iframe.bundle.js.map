{"version":3,"file":"main.13aa9500.iframe.bundle.js","mappings":";;;AAwDA;AAEA;;;;;;;;;;;;;AAaA;AAEA;;;;;;;;;;;;AAYA;;ACiSA;AAEA;AACA;AAIA;AAEA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AAHA;;;AAgBA;;;;AAUA;AAOA;AACA;AACA;AAOA;AACA;AACA;AAOA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AAyCA;AACA;AA+CA;AACA;;ACtgBA;;AC2CA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;AAEA;AAEA;;;AAGA;;;;AC5BA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;;AAGA;;AAIA;;;AAIA;;;AAIA;;;ACzFA;;;AAIA;;;;ACAA;;AAEA;AAGA;;AAGA;;;AAIA;;;;;;ACEA;;;;AAsCA;;;;;;;;;;AAWA;;;;;;;;;AAUA;;;;AAKA;;ACEA;;;;AAKA;;;;AAKA;AC3FA;AACA;AAEA;;;;;;;ACcA;;;;;;;;AAUA;AACA;AAGA;;;AAGA;;AAEA;;AAIA;AC/CA;AACA","sources":["webpack://@rocket.chat/fuselage/./src/components/AnimatedVisibility/AnimatedVisibility.tsx","webpack://@rocket.chat/fuselage/./src/components/Box/stylingProps.ts","webpack://@rocket.chat/fuselage/./src/components/ContextualbarV2/ContextualbarHeader.tsx","webpack://@rocket.chat/fuselage/./src/components/Margins/Margins.tsx","webpack://@rocket.chat/fuselage/./src/components/Scrollable/Scrollable.tsx","webpack://@rocket.chat/fuselage/./src/components/Slider/SliderHead.tsx","webpack://@rocket.chat/fuselage/./src/components/Slider/SliderThumb.tsx","webpack://@rocket.chat/fuselage/./src/components/Slider/SliderTrack.tsx","webpack://@rocket.chat/fuselage/./src/components/Slider/Slider.tsx","webpack://@rocket.chat/fuselage/./src/components/Throbber/Throbber.tsx","webpack://@rocket.chat/fuselage/./src/components/ToastBar/ToastBar.tsx","webpack://@rocket.chat/fuselage/./src/hooks/useArrayLikeClassNameProp.ts"],"sourcesContent":["import { css, keyframes } from '@rocket.chat/css-in-js';\nimport type { ReactNode } from 'react';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { appendClassName } from '../../helpers/appendClassName';\nimport { useStyle } from '../../hooks/useStyle';\nimport { BoxTransforms, useComposedBoxTransform } from '../Box/BoxTransforms';\n\nexport type VisibilityType =\n  | 'hidden'\n  | 'visible'\n  | 'hiding'\n  | 'unhiding'\n  | undefined;\n\ntype AnimatedVisibilityProps = {\n  children: ReactNode;\n  visibility?: VisibilityType;\n};\n\nconst Visibility = {\n  HIDDEN: 'hidden' as VisibilityType,\n  VISIBLE: 'visible' as VisibilityType,\n  HIDING: 'hiding' as VisibilityType,\n  UNHIDING: 'unhiding' as VisibilityType,\n};\n\nconst AnimatedVisibility = (props: AnimatedVisibilityProps) => {\n  const propVisibility = props.visibility || Visibility.HIDDEN;\n\n  const [visibility, setVisibility] = useState<VisibilityType>(propVisibility);\n\n  useEffect(() => {\n    setVisibility((visibility) => {\n      if (\n        propVisibility === Visibility.VISIBLE &&\n        visibility !== propVisibility\n      ) {\n        return Visibility.UNHIDING;\n      }\n\n      if (\n        propVisibility === Visibility.HIDDEN &&\n        visibility !== propVisibility\n      ) {\n        return Visibility.HIDING;\n      }\n\n      return visibility;\n    });\n  }, [propVisibility]);\n\n  const className = useStyle(\n    css`\n      animation-duration: 230ms;\n\n      ${visibility === Visibility.HIDING &&\n      css`\n        animation-name: ${keyframes`\n        from {\n          transform: translate3d(0, 0, 0);\n          opacity: 1;\n        }\n\n        to {\n          transform: translate3d(0, 1rem, 0);\n          opacity: 0;\n        }\n      `};\n      `}\n\n      ${visibility === Visibility.UNHIDING &&\n      css`\n        animation-name: ${keyframes`\n        from {\n          transform: translate3d(0, 1rem, 0);\n          opacity: 0;\n        }\n\n        to {\n          transform: translate3d(0, 0, 0);\n          opacity: 1;\n        }\n      `};\n      `}\n    `,\n    null\n  );\n\n  const handleAnimationEnd = useCallback(\n    () =>\n      setVisibility((visibility) => {\n        if (visibility === Visibility.HIDING) {\n          return Visibility.HIDDEN;\n        }\n\n        if (visibility === Visibility.UNHIDING) {\n          return Visibility.VISIBLE;\n        }\n\n        return visibility;\n      }),\n    []\n  );\n\n  const transformFn = useCallback(\n    (props) => {\n      if (props.onAnimationEnd === undefined) {\n        props.onAnimationEnd = handleAnimationEnd;\n      }\n      props.className =\n        className && appendClassName(props.className, className);\n      return props;\n    },\n    [className, handleAnimationEnd]\n  );\n\n  const composedFn = useComposedBoxTransform(transformFn);\n  if (visibility === Visibility.HIDDEN) {\n    return null;\n  }\n\n  return (\n    <BoxTransforms.Provider children={props.children} value={composedFn} />\n  );\n};\n\nexport default AnimatedVisibility;\n","import type { cssFn } from '@rocket.chat/css-in-js';\nimport { css } from '@rocket.chat/css-in-js';\nimport type { CSSProperties } from 'react';\n\nimport type { Var } from '../../Theme';\nimport { Palette } from '../../Theme';\nimport { fromCamelToKebab } from '../../helpers/fromCamelToKebab';\nimport {\n  borderRadius,\n  borderWidth,\n  backgroundColor,\n  fontColor,\n  fontFamily,\n  fontScale,\n  inset,\n  margin,\n  padding,\n  size,\n  strokeColor,\n} from '../../styleTokens';\n\ntype FontScale =\n  | 'hero'\n  | 'h1'\n  | 'h2'\n  | 'h3'\n  | 'h4'\n  | 'h5'\n  | 'p1'\n  | 'p1m'\n  | 'p1b'\n  | 'p2'\n  | 'p2m'\n  | 'p2b'\n  | 'c1'\n  | 'c2'\n  | 'micro';\n\nexport type StylingProps = {\n  border: CSSProperties['border'];\n  borderBlock: CSSProperties['borderBlock'];\n  borderBlockStart: CSSProperties['borderBlockStart'];\n  borderBlockEnd: CSSProperties['borderBlockEnd'];\n  borderInline: CSSProperties['borderInline'];\n  borderInlineStart: CSSProperties['borderInlineStart'];\n  borderInlineEnd: CSSProperties['borderInlineEnd'];\n  borderWidth: CSSProperties['borderWidth'];\n  borderBlockWidth: CSSProperties['borderBlockWidth'];\n  borderBlockStartWidth: CSSProperties['borderBlockStartWidth'];\n  borderBlockEndWidth: CSSProperties['borderBlockEndWidth'];\n  borderInlineWidth: CSSProperties['borderInlineWidth'];\n  borderInlineStartWidth: CSSProperties['borderInlineStartWidth'];\n  borderInlineEndWidth: CSSProperties['borderInlineEndWidth'];\n  borderStyle: CSSProperties['borderStyle'];\n  borderBlockStyle: CSSProperties['borderBlockStyle'];\n  borderBlockStartStyle: CSSProperties['borderBlockStartStyle'];\n  borderBlockEndStyle: CSSProperties['borderBlockEndStyle'];\n  borderInlineStyle: CSSProperties['borderInlineStyle'];\n  borderInlineStartStyle: CSSProperties['borderInlineStartStyle'];\n  borderInlineEndStyle: CSSProperties['borderInlineEndStyle'];\n  borderColor: CSSProperties['borderColor'];\n  borderBlockColor: CSSProperties['borderBlockColor'];\n  borderBlockStartColor: CSSProperties['borderBlockStartColor'];\n  borderBlockEndColor: CSSProperties['borderBlockEndColor'];\n  borderInlineColor: CSSProperties['borderInlineColor'];\n  borderInlineStartColor: CSSProperties['borderInlineStartColor'];\n  borderInlineEndColor: CSSProperties['borderInlineEndColor'];\n  borderRadius: CSSProperties['borderRadius'];\n  borderStartStartRadius: CSSProperties['borderStartStartRadius'];\n  borderStartEndRadius: CSSProperties['borderStartEndRadius'];\n  borderEndStartRadius: CSSProperties['borderEndStartRadius'];\n  borderEndEndRadius: CSSProperties['borderEndEndRadius'];\n\n  color: CSSProperties['color'] | Var;\n  backgroundColor: CSSProperties['backgroundColor'] | Var;\n  bg: CSSProperties['backgroundColor'] | Var;\n  opacity: CSSProperties['opacity'];\n\n  alignItems: CSSProperties['alignItems'];\n  alignContent: CSSProperties['alignContent'];\n  justifyItems: CSSProperties['justifyItems'];\n  justifyContent: CSSProperties['justifyContent'];\n  flexWrap: CSSProperties['flexWrap'];\n  flexDirection: CSSProperties['flexDirection'];\n  flexGrow: CSSProperties['flexGrow'];\n  flexShrink: CSSProperties['flexShrink'];\n  flexBasis: CSSProperties['flexBasis'];\n  justifySelf: CSSProperties['justifySelf'];\n  alignSelf: CSSProperties['alignSelf'];\n  order: CSSProperties['order'];\n\n  w: CSSProperties['width'];\n  width: CSSProperties['width'];\n  minWidth: CSSProperties['minWidth'];\n  maxWidth: CSSProperties['maxWidth'];\n  h: CSSProperties['height'];\n  height: CSSProperties['height'];\n  minHeight: CSSProperties['minHeight'];\n  maxHeight: CSSProperties['maxHeight'];\n  display: CSSProperties['display'];\n  verticalAlign: CSSProperties['verticalAlign'];\n  overflow: CSSProperties['overflow'];\n  overflowX: CSSProperties['overflowX'];\n  overflowY: CSSProperties['overflowY'];\n\n  position: CSSProperties['position'];\n  zIndex: CSSProperties['zIndex'];\n  inset: CSSProperties['inset'];\n  insetBlock: CSSProperties['insetBlock'];\n  insetBlockStart: CSSProperties['insetBlockStart'];\n  insetBlockEnd: CSSProperties['insetBlockEnd'];\n  insetInline: CSSProperties['insetInline'];\n  insetInlineStart: CSSProperties['insetInlineStart'];\n  insetInlineEnd: CSSProperties['insetInlineEnd'];\n\n  m: CSSProperties['margin'];\n  margin: CSSProperties['margin'];\n  mb: CSSProperties['marginBlock'];\n  marginBlock: CSSProperties['marginBlock'];\n  mbs: CSSProperties['marginBlockStart'];\n  marginBlockStart: CSSProperties['marginBlockStart'];\n  mbe: CSSProperties['marginBlockEnd'];\n  marginBlockEnd: CSSProperties['marginBlockEnd'];\n  mi: CSSProperties['marginInline'];\n  marginInline: CSSProperties['marginInline'];\n  mis: CSSProperties['marginInlineStart'];\n  marginInlineStart: CSSProperties['marginInlineStart'];\n  mie: CSSProperties['marginInlineEnd'];\n  marginInlineEnd: CSSProperties['marginInlineEnd'];\n  p: CSSProperties['padding'];\n  padding: CSSProperties['padding'];\n  pb: CSSProperties['paddingBlock'];\n  paddingBlock: CSSProperties['paddingBlock'];\n  pbs: CSSProperties['paddingBlockStart'];\n  paddingBlockStart: CSSProperties['paddingBlockStart'];\n  pbe: CSSProperties['paddingBlockEnd'];\n  paddingBlockEnd: CSSProperties['paddingBlockEnd'];\n  pi: CSSProperties['paddingInline'];\n  paddingInline: CSSProperties['paddingInline'];\n  pis: CSSProperties['paddingInlineStart'];\n  paddingInlineStart: CSSProperties['paddingInlineStart'];\n  pie: CSSProperties['paddingInlineEnd'];\n  paddingInlineEnd: CSSProperties['paddingInlineEnd'];\n\n  fontFamily: CSSProperties['fontFamily'] | FontScale;\n  fontSize: CSSProperties['fontSize'] | FontScale;\n  fontStyle: CSSProperties['fontStyle'];\n  fontWeight: CSSProperties['fontWeight'] | FontScale;\n  letterSpacing: CSSProperties['letterSpacing'] | FontScale;\n  lineHeight: CSSProperties['lineHeight'] | FontScale;\n  textAlign: CSSProperties['textAlign'];\n  textTransform: CSSProperties['textTransform'];\n  textDecorationLine: CSSProperties['textDecorationLine'];\n  wordBreak: CSSProperties['wordBreak'];\n\n  elevation: '0' | '1' | '2' | '1nb' | '2nb';\n  invisible: boolean;\n  withTruncatedText: boolean;\n  size: CSSProperties['blockSize'];\n  minSize: CSSProperties['blockSize'];\n  maxSize: CSSProperties['blockSize'];\n  fontScale: FontScale;\n};\n\ntype PropDefinition =\n  | {\n      toCSSValue: (value: unknown) => string | undefined;\n    }\n  | { aliasOf: keyof StylingProps }\n  | {\n      toStyle: (value: unknown) => cssFn | undefined;\n    };\n\nconst stringProp: PropDefinition = {\n  toCSSValue: (value) => (typeof value === 'string' ? value : undefined),\n};\n\nconst numberOrStringProp: PropDefinition = {\n  toCSSValue: (value) => {\n    if (typeof value === 'number' || typeof value === 'string') {\n      return String(value);\n    }\n\n    return undefined;\n  },\n};\n\nconst borderWidthProp: PropDefinition = {\n  toCSSValue: borderWidth,\n};\n\nconst borderRadiusProp: PropDefinition = {\n  toCSSValue: borderRadius,\n};\n\nconst backgroundColorProp: PropDefinition = {\n  toCSSValue: backgroundColor,\n};\n\nconst fontColorProp: PropDefinition = {\n  toCSSValue: fontColor,\n};\n\nconst strokeColorProp: PropDefinition = {\n  toCSSValue: strokeColor,\n};\n\nconst sizeProp: PropDefinition = {\n  toCSSValue: size,\n};\n\nconst insetProp: PropDefinition = {\n  toCSSValue: inset,\n};\n\nconst marginProp: PropDefinition = {\n  toCSSValue: margin,\n};\n\nconst paddingProp: PropDefinition = {\n  toCSSValue: padding,\n};\n\nconst fontFamilyProp: PropDefinition = {\n  toCSSValue: fontFamily,\n};\n\nconst fontSizeProp: PropDefinition = {\n  toCSSValue: (value) => fontScale(value)?.fontSize || size(value),\n};\n\nconst fontWeightProp: PropDefinition = {\n  toCSSValue: (value) =>\n    value ? String(fontScale(value)?.fontWeight || value) : undefined,\n};\n\nconst lineHeightProp: PropDefinition = {\n  toCSSValue: (value) => fontScale(value)?.lineHeight || size(value),\n};\n\nconst letterSpacingProp: PropDefinition = {\n  toCSSValue: (value) =>\n    value ? String(fontScale(value)?.letterSpacing || value) : undefined,\n};\n\nconst aliasOf = (propName: keyof StylingProps): PropDefinition => ({\n  aliasOf: propName,\n});\n\nexport const propDefs: Record<keyof StylingProps, PropDefinition> = {\n  border: stringProp,\n  borderBlock: stringProp,\n  borderBlockStart: stringProp,\n  borderBlockEnd: stringProp,\n  borderInline: stringProp,\n  borderInlineStart: stringProp,\n  borderInlineEnd: stringProp,\n  borderWidth: borderWidthProp,\n  borderBlockWidth: borderWidthProp,\n  borderBlockStartWidth: borderWidthProp,\n  borderBlockEndWidth: borderWidthProp,\n  borderInlineWidth: borderWidthProp,\n  borderInlineStartWidth: borderWidthProp,\n  borderInlineEndWidth: borderWidthProp,\n  borderStyle: stringProp,\n  borderBlockStyle: stringProp,\n  borderBlockStartStyle: stringProp,\n  borderBlockEndStyle: stringProp,\n  borderInlineStyle: stringProp,\n  borderInlineStartStyle: stringProp,\n  borderInlineEndStyle: stringProp,\n  borderColor: strokeColorProp,\n  borderBlockColor: strokeColorProp,\n  borderBlockStartColor: strokeColorProp,\n  borderBlockEndColor: strokeColorProp,\n  borderInlineColor: strokeColorProp,\n  borderInlineStartColor: strokeColorProp,\n  borderInlineEndColor: strokeColorProp,\n  borderRadius: borderRadiusProp,\n  borderStartStartRadius: borderRadiusProp,\n  borderStartEndRadius: borderRadiusProp,\n  borderEndStartRadius: borderRadiusProp,\n  borderEndEndRadius: borderRadiusProp,\n\n  color: fontColorProp,\n  backgroundColor: backgroundColorProp,\n  bg: aliasOf('backgroundColor'),\n  opacity: numberOrStringProp,\n\n  alignItems: stringProp,\n  alignContent: stringProp,\n  justifyItems: stringProp,\n  justifyContent: stringProp,\n  flexWrap: stringProp,\n  flexDirection: stringProp,\n  flexGrow: numberOrStringProp,\n  flexShrink: numberOrStringProp,\n  flexBasis: stringProp,\n  justifySelf: stringProp,\n  alignSelf: stringProp,\n  order: numberOrStringProp,\n\n  w: aliasOf('width'),\n  width: sizeProp,\n  minWidth: sizeProp,\n  maxWidth: sizeProp,\n  h: aliasOf('height'),\n  height: sizeProp,\n  minHeight: sizeProp,\n  maxHeight: sizeProp,\n  display: stringProp,\n  verticalAlign: stringProp,\n  overflow: stringProp,\n  overflowX: stringProp,\n  overflowY: stringProp,\n\n  position: stringProp,\n  zIndex: numberOrStringProp,\n  inset: insetProp,\n  insetBlock: insetProp,\n  insetBlockStart: insetProp,\n  insetBlockEnd: insetProp,\n  insetInline: insetProp,\n  insetInlineStart: insetProp,\n  insetInlineEnd: insetProp,\n\n  m: aliasOf('margin'),\n  margin: marginProp,\n  mb: aliasOf('marginBlock'),\n  marginBlock: marginProp,\n  mbs: aliasOf('marginBlockStart'),\n  marginBlockStart: marginProp,\n  mbe: aliasOf('marginBlockEnd'),\n  marginBlockEnd: marginProp,\n  mi: aliasOf('marginInline'),\n  marginInline: marginProp,\n  mis: aliasOf('marginInlineStart'),\n  marginInlineStart: marginProp,\n  mie: aliasOf('marginInlineEnd'),\n  marginInlineEnd: marginProp,\n  p: aliasOf('padding'),\n  padding: paddingProp,\n  pb: aliasOf('paddingBlock'),\n  paddingBlock: paddingProp,\n  pbs: aliasOf('paddingBlockStart'),\n  paddingBlockStart: paddingProp,\n  pbe: aliasOf('paddingBlockEnd'),\n  paddingBlockEnd: paddingProp,\n  pi: aliasOf('paddingInline'),\n  paddingInline: paddingProp,\n  pis: aliasOf('paddingInlineStart'),\n  paddingInlineStart: paddingProp,\n  pie: aliasOf('paddingInlineEnd'),\n  paddingInlineEnd: paddingProp,\n\n  fontFamily: fontFamilyProp,\n  fontSize: fontSizeProp,\n  fontStyle: stringProp,\n  fontWeight: fontWeightProp,\n  letterSpacing: letterSpacingProp,\n  lineHeight: lineHeightProp,\n  textAlign: stringProp,\n  textTransform: stringProp,\n  textDecorationLine: stringProp,\n  wordBreak: stringProp,\n\n  elevation: {\n    toStyle: (value) => {\n      if (value === '0') {\n        return css`\n          box-shadow: none;\n        `;\n      }\n\n      if (value === '1') {\n        return css`\n          box-shadow: 0px 0px 12px 0px ${Palette.shadow['shadow-elevation-1']};\n          border: 1px solid ${Palette.shadow['shadow-elevation-border']};\n        `;\n      }\n\n      if (value === '1nb') {\n        return css`\n          box-shadow: 0px 0px 12px 0px ${Palette.shadow['shadow-elevation-1']};\n        `;\n      }\n\n      if (value === '2') {\n        return css`\n          box-shadow: 0px 0px 2px 0px ${Palette.shadow['shadow-elevation-2x']},\n            0px 0px 12px 0px ${Palette.shadow['shadow-elevation-2y']};\n          border: 1px solid ${Palette.shadow['shadow-elevation-border']};\n        `;\n      }\n\n      if (value === '2nb') {\n        return css`\n          box-shadow: 0px 0px 2px 0px ${Palette.shadow['shadow-elevation-2x']},\n            0px 0px 12px 0px ${Palette.shadow['shadow-elevation-2y']};\n        `;\n      }\n\n      return undefined;\n    },\n  },\n  invisible: {\n    toStyle: (value) =>\n      value\n        ? css`\n            visibility: hidden;\n            opacity: 0;\n          `\n        : undefined,\n  },\n  withTruncatedText: {\n    toStyle: (value) =>\n      value\n        ? css`\n            overflow: hidden;\n            text-overflow: ellipsis;\n            white-space: nowrap;\n          `\n        : undefined,\n  },\n  size: {\n    toStyle: (value) =>\n      size(value)\n        ? css`\n            width: ${size(value)} !important;\n            height: ${size(value)} !important;\n          `\n        : undefined,\n  },\n  minSize: {\n    toStyle: (value) =>\n      size(value)\n        ? css`\n            min-width: ${size(value)} !important;\n            min-height: ${size(value)} !important;\n          `\n        : undefined,\n  },\n  maxSize: {\n    toStyle: (value) =>\n      size(value)\n        ? css`\n            max-width: ${size(value)} !important;\n            max-height: ${size(value)} !important;\n          `\n        : undefined,\n  },\n  fontScale: {\n    toStyle: (value) => css`\n      font-size: ${fontScale(value)?.fontSize} !important;\n      font-weight: ${fontScale(value)?.fontWeight} !important;\n      letter-spacing: ${fontScale(value)?.letterSpacing} !important;\n      line-height: ${fontScale(value)?.lineHeight} !important;\n    `,\n  },\n};\n\nconst compiledPropDefs = new Map(\n  (Object.entries(propDefs) as [keyof StylingProps, PropDefinition][]).map(\n    ([propName, propDef]): [\n      propName: string,\n      inject: (\n        value: unknown,\n        stylingProps: Map<keyof StylingProps, cssFn>\n      ) => void\n    ] => {\n      if ('aliasOf' in propDef) {\n        const { aliasOf: effectivePropName } = propDef;\n\n        return [\n          propName,\n          (value, stylingProps) => {\n            if (stylingProps.has(effectivePropName)) {\n              return;\n            }\n\n            const inject = compiledPropDefs.get(effectivePropName);\n\n            inject?.(value, stylingProps);\n          },\n        ];\n      }\n\n      if ('toCSSValue' in propDef) {\n        const cssProperty = fromCamelToKebab(propName);\n        const { toCSSValue } = propDef;\n        return [\n          propName,\n          (value, stylingProps) => {\n            const cssValue = toCSSValue(value);\n\n            if (cssValue === undefined) {\n              return;\n            }\n\n            stylingProps.set(\n              propName,\n              css`\n                ${cssProperty}: ${cssValue} !important;\n              `\n            );\n          },\n        ];\n      }\n\n      const { toStyle } = propDef;\n\n      return [\n        propName,\n        (value, stylingProps) => {\n          const style = toStyle(value);\n\n          if (style === undefined) {\n            return;\n          }\n\n          stylingProps.set(propName, style);\n        },\n      ];\n    }\n  )\n);\n\nexport const extractStylingProps = <TProps extends Record<string, unknown>>(\n  props: TProps & Partial<StylingProps>\n): [props: TProps, styles: cssFn | undefined] => {\n  const stylingProps = new Map<keyof StylingProps, cssFn>();\n  const newProps: Record<string, unknown> = {};\n\n  for (const [propName, value] of Object.entries(props)) {\n    const inject = compiledPropDefs.get(propName);\n\n    if (!inject) {\n      newProps[propName] = value;\n      continue;\n    }\n\n    if (value === undefined) {\n      continue;\n    }\n\n    inject(value, stylingProps);\n  }\n\n  const styles = stylingProps.size\n    ? css`\n        ${Array.from(stylingProps.values())}\n      `\n    : undefined;\n\n  return [newProps as TProps, styles];\n};\n","import { css } from '@rocket.chat/css-in-js';\nimport type { ComponentProps } from 'react';\nimport { memo } from 'react';\n\nimport Box from '../Box';\n\ntype ContextualbarHeaderProps = ComponentProps<typeof Box>;\n\nconst ContextualbarHeader = ({\n  children,\n  ...props\n}: ContextualbarHeaderProps) => (\n  <Box\n    display='flex'\n    alignItems='center'\n    height='x44'\n    pi={16}\n    borderBlockEndWidth='default'\n    borderBlockColor='extra-light'\n    flexShrink={0}\n    {...props}\n  >\n    <Box\n      display='flex'\n      alignItems='center'\n      justifyContent='space-between'\n      flexGrow={1}\n      height='100%'\n      overflow='hidden'\n      className={css`\n        gap: 8px;\n      `}\n    >\n      {children}\n    </Box>\n  </Box>\n);\n\nexport default memo(ContextualbarHeader);\n","import { css } from '@rocket.chat/css-in-js';\nimport type { ComponentProps, PropsWithChildren } from 'react';\nimport { useCallback } from 'react';\n\nimport { appendClassName } from '../../helpers/appendClassName';\nimport { patchChildren } from '../../helpers/patchChildren';\nimport { useStyle } from '../../hooks/useStyle';\nimport { margin } from '../../styleTokens';\nimport type Box from '../Box';\nimport { BoxTransforms, useComposedBoxTransform } from '../Box/BoxTransforms';\n\ntype MarginsProps = PropsWithChildren<{\n  all?: ComponentProps<typeof Box>['margin'];\n  block?: ComponentProps<typeof Box>['marginBlock'];\n  blockStart?: ComponentProps<typeof Box>['marginBlockStart'];\n  blockEnd?: ComponentProps<typeof Box>['marginBlockEnd'];\n  inline?: ComponentProps<typeof Box>['marginInline'];\n  inlineStart?: ComponentProps<typeof Box>['marginInlineStart'];\n  inlineEnd?: ComponentProps<typeof Box>['marginInlineEnd'];\n  className?: string;\n}>;\n\n/**\n * Add margins to the wrapped component.\n */\nexport const Margins = (props: MarginsProps) => {\n  const {\n    children,\n    className,\n    all,\n    block,\n    blockStart,\n    blockEnd,\n    inline,\n    inlineStart,\n    inlineEnd,\n  } = props;\n\n  const transformFn = useCallback(\n    (props) => {\n      if (all !== undefined && props.margin === undefined) {\n        props.margin = all;\n      }\n\n      if (block !== undefined && props.marginBlock === undefined) {\n        props.marginBlock = block;\n      }\n\n      if (blockStart !== undefined && props.marginBlockStart === undefined) {\n        props.marginBlockStart = blockStart;\n      }\n\n      if (blockEnd !== undefined && props.marginBlockEnd === undefined) {\n        props.marginBlockEnd = blockEnd;\n      }\n\n      if (inline !== undefined && props.marginInline === undefined) {\n        props.marginInline = inline;\n      }\n\n      if (inlineStart !== undefined && props.marginInlineStart === undefined) {\n        props.marginInlineStart = inlineStart;\n      }\n\n      if (inlineEnd !== undefined && props.marginInlineEnd === undefined) {\n        props.marginInlineEnd = inlineEnd;\n      }\n\n      return props;\n    },\n    [all, block, blockEnd, blockStart, inline, inlineEnd, inlineStart]\n  );\n\n  const marginsClassName = useStyle(\n    css`\n      &:not(.rcx-box--full) {\n        ${props.all &&\n        css`\n          margin: ${margin(props.all)};\n        `}\n        ${props.inline &&\n        css`\n          margin-inline: ${margin(props.inline)};\n        `}\n      ${props.inlineStart &&\n        css`\n          margin-inline-start: ${margin(props.inlineStart)};\n        `}\n      ${props.inlineEnd &&\n        css`\n          margin-inline-end: ${margin(props.inlineEnd)};\n        `}\n      ${props.block &&\n        css`\n          margin-block: ${margin(props.block)};\n        `}\n      ${props.blockStart &&\n        css`\n          margin-block-start: ${margin(props.blockStart)};\n        `}\n      ${props.blockEnd &&\n        css`\n          margin-block-end: ${margin(props.blockEnd)};\n        `}\n      }\n    `,\n    props\n  ) as string;\n\n  const patchedChildren = patchChildren(\n    children,\n    (childProps: {\n      className: string | string[];\n      [index: string]: unknown;\n    }) => ({\n      className: appendClassName(\n        childProps.className,\n        appendClassName(className, marginsClassName)\n      ),\n    })\n  );\n\n  return (\n    <BoxTransforms.Provider\n      children={patchedChildren}\n      value={useComposedBoxTransform(transformFn)}\n    />\n  );\n};\n","import { css } from '@rocket.chat/css-in-js';\nimport { useEffectEvent } from '@rocket.chat/fuselage-hooks';\nimport type { PropsWithChildren, MouseEvent, MutableRefObject } from 'react';\nimport { useRef, useCallback } from 'react';\n\nimport { appendClassName } from '../../helpers/appendClassName';\nimport { useStyle } from '../../hooks/useStyle';\nimport { BoxTransforms, useComposedBoxTransform } from '../Box/BoxTransforms';\n\ntype ScrollableProps = PropsWithChildren<{\n  horizontal?: boolean;\n  vertical?: boolean;\n  smooth?: boolean;\n  onScrollContent?: (touching: { top: boolean }) => void;\n}>;\n\nconst getTouchingEdges = (element: Element) => ({\n  top: !element.scrollTop,\n  bottom: !(element.scrollTop + element.clientHeight - element.scrollHeight),\n  left: !element.scrollLeft,\n  right: !(element.scrollLeft + element.clientWidth - element.scrollWidth),\n});\n\nconst pollTouchingEdges = (\n  element: EventTarget & Element,\n  touchingEdgesRef: MutableRefObject<Record<string, boolean>>,\n  onScrollContent: ((touching: { top: boolean }) => void) | undefined\n) => {\n  const touchingEdges = touchingEdgesRef.current;\n  const newTouchingEdges = getTouchingEdges(element);\n\n  const dirty =\n    touchingEdges &&\n    (touchingEdges.top !== newTouchingEdges.top ||\n      touchingEdges.bottom !== newTouchingEdges.bottom ||\n      touchingEdges.left !== newTouchingEdges.left ||\n      touchingEdges.right !== newTouchingEdges.right);\n\n  if (dirty) {\n    touchingEdgesRef.current = newTouchingEdges;\n    onScrollContent && onScrollContent(newTouchingEdges);\n  }\n};\n\n/**\n * Add scroll capability to the wrapped component.\n */\nexport const Scrollable = ({\n  children,\n  horizontal,\n  vertical,\n  smooth,\n  onScrollContent,\n}: ScrollableProps) => {\n  const scrollTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const touchingEdgesRef = useRef({});\n\n  const handleScroll = useEffectEvent((event: MouseEvent) => {\n    const element = event.currentTarget;\n\n    if (!scrollTimeoutRef.current) {\n      pollTouchingEdges(element, touchingEdgesRef, onScrollContent);\n    }\n\n    scrollTimeoutRef.current && clearTimeout(scrollTimeoutRef.current);\n\n    scrollTimeoutRef.current = setTimeout(() => {\n      scrollTimeoutRef.current = undefined;\n      pollTouchingEdges(element, touchingEdgesRef, onScrollContent);\n    }, 200);\n  });\n\n  const className = useStyle(\n    css`\n      position: relative;\n\n      &::-webkit-scrollbar {\n        width: ${4 / 16}rem;\n        height: ${4 / 16}rem;\n      }\n\n      &::-webkit-scrollbar-track {\n        background-color: transparent;\n      }\n\n      &::-webkit-scrollbar-thumb {\n        background-color: rgba(0, 0, 0, 0.05);\n        background-color: var(\n          --rcx-theme-scrollbar-thumb-color,\n          rgba(0, 0, 0, 0.05)\n        );\n      }\n\n      &:hover::-webkit-scrollbar-thumb {\n        background-color: rgba(0, 0, 0, 0.15);\n        background-color: var(\n          --rcx-theme-scrollbar-thumb-hover-color,\n          rgba(0, 0, 0, 0.15)\n        );\n      }\n\n      ${(horizontal &&\n        css`\n          overflow-x: auto !important;\n        `) ||\n      (vertical &&\n        css`\n          overflow-y: auto !important;\n        `) ||\n      css`\n        overflow: auto !important;\n      `}\n      ${smooth &&\n      css`\n        scroll-behavior: smooth !important;\n      `}\n    `,\n    null\n  );\n\n  const transformFn = useCallback(\n    (props) => {\n      props.className =\n        className && appendClassName(props.className, className);\n\n      if (onScrollContent !== undefined && props.onScroll === undefined) {\n        props.onScroll = handleScroll;\n      }\n\n      return props;\n    },\n    [className, handleScroll, onScrollContent]\n  );\n\n  return (\n    <BoxTransforms.Provider\n      children={children}\n      value={useComposedBoxTransform(transformFn)}\n    />\n  );\n};\n","import { css } from '@rocket.chat/css-in-js';\nimport type { LabelHTMLAttributes, OutputHTMLAttributes } from 'react';\nimport type { SliderState } from 'react-stately';\n\nimport { useStyle } from '../../hooks/useStyle';\nimport { Label } from '../Label';\n\ntype SliderHeadProps = {\n  state: SliderState;\n  labelProps: Omit<LabelHTMLAttributes<HTMLLabelElement>, 'is'>;\n  outputProps: Omit<OutputHTMLAttributes<HTMLOutputElement>, 'is'>;\n  label?: string;\n  showOutput?: boolean;\n  multiThumb?: boolean;\n};\nexport const SliderHead = ({\n  state,\n  labelProps,\n  outputProps,\n  label,\n  showOutput = true,\n  multiThumb,\n}: SliderHeadProps) => {\n  const labelContainer = useStyle(\n    css`\n      display: flex;\n      justify-content: space-between;\n      ${state.orientation === 'vertical' &&\n      css`\n        flex-direction: column;\n      `}\n    `,\n    null\n  );\n  const output = (\n    <Label {...(outputProps as any)}>\n      {multiThumb ? (\n        <Label {...outputProps} data-testid='slider-output'>\n          {`${state.getThumbValueLabel(0)} - ${state.getThumbValueLabel(1)}`}\n        </Label>\n      ) : (\n        <Label {...outputProps} data-testid='slider-output'>\n          {state.getThumbValueLabel(0)}\n        </Label>\n      )}\n    </Label>\n  );\n  return (\n    <>\n      {label ? (\n        <div className={labelContainer}>\n          <Label {...labelProps}>{label}</Label>\n          {showOutput && output}\n        </div>\n      ) : (\n        showOutput && output\n      )}\n    </>\n  );\n};\n","import { css } from '@rocket.chat/css-in-js';\nimport { useRef } from 'react';\nimport {\n  mergeProps,\n  useFocusRing,\n  useSliderThumb,\n  VisuallyHidden,\n} from 'react-aria';\n\nimport { Palette } from '../../Theme';\nimport { useStyle } from '../../hooks/useStyle';\n\nexport const SliderThumb = (props: any) => {\n  const { state, trackRef, index } = props;\n  const inputRef = useRef(null);\n  const { thumbProps, inputProps, isDragging } = useSliderThumb(\n    {\n      index,\n      trackRef,\n      inputRef,\n    },\n    state\n  );\n\n  const { focusProps, isFocusVisible } = useFocusRing();\n\n  const thumb = useStyle(\n    css`\n      width: 12px;\n      height: 12px;\n\n      cursor: ${state.isDisabled ? 'not-allowed' : 'pointer'};\n      border-radius: 50%;\n      background: ${isFocusVisible || isDragging\n        ? Palette.text['font-info']\n        : Palette.stroke['stroke-highlight']};\n      ${state.orientation === 'horizontal'\n        ? css`\n            top: 50%;\n          `\n        : css`\n            left: 50%;\n          `}\n    `,\n    { isFocusVisible, isDragging }\n  );\n  return (\n    <div {...thumbProps} className={thumb}>\n      <VisuallyHidden>\n        <input ref={inputRef} {...mergeProps(inputProps, focusProps)} />\n      </VisuallyHidden>\n    </div>\n  );\n};\n","import { css } from '@rocket.chat/css-in-js';\nimport type { DOMAttributes, MutableRefObject, ReactNode } from 'react';\nimport { useMemo } from 'react';\nimport type { SliderState } from 'react-stately';\n\nimport { Palette } from '../../Theme';\nimport { useStyle } from '../../hooks/useStyle';\n\ntype SliderTrackProps = {\n  trackProps: DOMAttributes<Element>;\n  trackRef: MutableRefObject<null>;\n  state: SliderState;\n  children: ReactNode;\n  multiThumb?: boolean;\n};\n\nconst highlight = Palette.stroke['stroke-highlight'];\nconst light = Palette.stroke['stroke-light'];\n\nexport const SliderTrack = ({\n  trackProps,\n  trackRef,\n  state,\n  multiThumb,\n  children,\n}: SliderTrackProps) => {\n  const isHorizontal = useMemo(\n    () => state.orientation === 'horizontal',\n    [state.orientation]\n  );\n  const isVertical = useMemo(\n    () => state.orientation === 'vertical',\n    [state.orientation]\n  );\n\n  const getThumbPosition = useMemo(\n    () => (value: number) => {\n      const maxValue = state.getThumbMaxValue(1) || state.getThumbMaxValue(0);\n      const minValue = state.getThumbMinValue(0);\n      return (value / (maxValue - minValue)) * 100;\n    },\n    [state]\n  );\n\n  const getTrackGradient = () => {\n    if (isHorizontal) {\n      return multiThumb\n        ? `to right, ${light} ${getThumbPosition(\n            state.values[0]\n          )}%, ${highlight} 0, ${highlight} ${getThumbPosition(\n            state.values[1]\n          )}%, ${light} 0`\n        : `to right, ${highlight}  ${getThumbPosition(\n            state.values[0]\n          )}%, ${light} 0%`;\n    }\n\n    if (isVertical) {\n      return multiThumb\n        ? `to top, ${light} ${getThumbPosition(\n            state.values[0]\n          )}%, ${highlight} 0, ${highlight} ${getThumbPosition(\n            state.values[1]\n          )}%, ${light} 0`\n        : `to top, ${highlight}  ${getThumbPosition(\n            state.values[0]\n          )}%, ${light} 0%`;\n    }\n\n    return undefined;\n  };\n\n  const track = useStyle(\n    css`\n      &::before {\n        position: absolute;\n        display: block;\n        content: attr(x);\n\n        background: linear-gradient(${getTrackGradient()});\n        transform: translateX(-50%);\n        border-radius: 1rem;\n      }\n      ${isHorizontal &&\n      css`\n        width: 100%;\n        height: 30px;\n        &::before {\n          top: 50%;\n          width: 100%;\n          height: 4px;\n          transform: translateY(-50%);\n        }\n      `};\n      ${isVertical &&\n      css`\n        width: 30px;\n        height: 100%;\n        &::before {\n          left: 50%;\n          width: 4px;\n          height: 100%;\n        }\n      `};\n      ${state.isDisabled &&\n      css`\n        cursor: not-allowed;\n        opacity: 0.4;\n      `};\n    `,\n    state\n  );\n\n  return (\n    <div {...trackProps} ref={trackRef} className={track}>\n      {children}\n    </div>\n  );\n};\n","/* eslint-disable no-nested-ternary */\nimport { css } from '@rocket.chat/css-in-js';\nimport type { AriaAttributes, ReactElement } from 'react';\nimport { useMemo, useRef } from 'react';\nimport type { AriaSliderProps } from 'react-aria';\nimport { useNumberFormatter, useSlider } from 'react-aria';\nimport { useSliderState } from 'react-stately';\n\nimport { useStyle } from '../../hooks/useStyle';\nimport { SliderHead } from './SliderHead';\nimport { SliderThumb } from './SliderThumb';\nimport { SliderTrack } from './SliderTrack';\n\ntype SliderProps<T extends number | number[]> = AriaAttributes & {\n  /**\n   * The display format of the value output.\n   */\n  formatOptions?: Intl.NumberFormatOptions;\n  label?: string;\n  showOutput?: boolean;\n  /**\n   * Slider with multiple thumbs.\n   * @default false\n   */\n  multiThumb?: T extends number[] ? true : false;\n  step?: number;\n  /**\n   * @default 0\n   */\n  minValue?: number;\n  /**\n   * @default 100\n   */\n  maxValue?: number;\n  orientation?: 'horizontal' | 'vertical';\n  disabled?: boolean;\n  defaultValue?: T;\n} & (\n    | {\n        value: T;\n        onChange: (value: T) => void;\n      }\n    | {\n        value?: never;\n        onChange?: never;\n      }\n  );\n\nexport function Slider<T extends number | [min: number, max: number]>(\n  props: SliderProps<T>\n): ReactElement {\n  const {\n    label,\n    formatOptions,\n    showOutput = true,\n    multiThumb,\n    maxValue,\n    minValue,\n  } = props;\n\n  // Get a defaultValue in the range for multiThumb\n  const getMultiThumbDefaultValue = (): T | undefined => {\n    if (multiThumb && !defaultValue) {\n      if (minValue && maxValue) {\n        return [minValue, maxValue] as T;\n      }\n      if (minValue) {\n        return [minValue, 100] as T;\n      }\n      if (maxValue) {\n        return [0, maxValue] as T;\n      }\n      return [0, 100] as T;\n    }\n\n    return undefined;\n  };\n\n  const { defaultValue = getMultiThumbDefaultValue() } = props;\n\n  const sliderProps = {\n    ...props,\n    isDisabled: props.disabled,\n  } as AriaSliderProps<number | number[]>;\n\n  const trackRef = useRef(null);\n  const numberFormatter = useNumberFormatter(formatOptions);\n  const sliderState = useSliderState({\n    defaultValue,\n    ...sliderProps,\n    numberFormatter,\n  });\n\n  const { groupProps, trackProps, labelProps, outputProps } = useSlider(\n    sliderProps,\n    sliderState,\n    trackRef\n  );\n\n  const isHorizontal = useMemo(\n    () => sliderState.orientation === 'horizontal',\n    [sliderState.orientation]\n  );\n  const isVertical = useMemo(\n    () => sliderState.orientation === 'vertical',\n    [sliderState.orientation]\n  );\n\n  const slider = useStyle(\n    css`\n      display: flex;\n      ${isHorizontal &&\n      css`\n        flex-direction: column;\n        width: 100%;\n      `};\n      ${isVertical &&\n      css`\n        flex-direction: row-reverse;\n        height: 100%;\n      `}\n    `,\n    sliderState\n  );\n\n  return (\n    <div {...groupProps} className={slider}>\n      <SliderHead\n        labelProps={labelProps}\n        outputProps={outputProps}\n        state={sliderState}\n        showOutput={showOutput}\n        label={label}\n        multiThumb={multiThumb}\n      />\n      <SliderTrack\n        state={sliderState}\n        trackProps={trackProps}\n        trackRef={trackRef}\n        multiThumb={multiThumb}\n      >\n        <SliderThumb index={0} state={sliderState} trackRef={trackRef} />\n        {multiThumb && (\n          <SliderThumb index={1} state={sliderState} trackRef={trackRef} />\n        )}\n      </SliderTrack>\n    </div>\n  );\n}\n","import { css } from '@rocket.chat/css-in-js';\nimport type { ComponentProps, Ref } from 'react';\nimport { forwardRef } from 'react';\n\nimport Box from '../Box';\n\ntype ThrobberProps = Omit<ComponentProps<typeof Box>, 'disabled'> & {\n  circleCount?: number;\n  disabled?: boolean;\n  inheritColor?: boolean;\n};\n\ntype CircleProps = {\n  circleCount: number;\n  iteration: number;\n  inheritColor?: boolean;\n  disabled?: boolean;\n} & Pick<ComponentProps<typeof Box>, 'size'>;\n\nfunction Circle({\n  disabled,\n  circleCount,\n  iteration,\n  inheritColor,\n  ...props\n}: CircleProps) {\n  return (\n    <Box\n      is='span'\n      className={css`\n        animation-duration: ${circleCount * 0.466}s;\n        animation-delay: ${iteration * 0.16}s;\n      `}\n      rcx-throbber__circle\n      rcx-throbber__circle--disabled={disabled}\n      rcx-throbber__circle--inherit-color={inheritColor}\n      {...props}\n    />\n  );\n}\n\n/**\n * Indicates content that has not loaded yet.\n */\nexport const Throbber = forwardRef(function Throbber(\n  {\n    disabled,\n    size = 'x16',\n    circleCount = 3,\n    inheritColor,\n    ...props\n  }: ThrobberProps,\n  ref: Ref<HTMLElement>\n) {\n  return (\n    <Box rcx-throbber ref={ref} {...props}>\n      {Array.from({ length: circleCount || 3 }, (_, iteration) => (\n        <Circle\n          key={iteration}\n          circleCount={circleCount}\n          iteration={iteration}\n          disabled={!!disabled}\n          size={size}\n          inheritColor={!!inheritColor}\n        />\n      ))}\n    </Box>\n  );\n});\n","import { css, keyframes } from '@rocket.chat/css-in-js';\nimport { useUniqueId } from '@rocket.chat/fuselage-hooks';\nimport type { ReactNode, AllHTMLAttributes } from 'react';\n\nimport Box from '../Box';\nimport { IconButton } from '../Button';\nimport { Icon } from '../Icon';\n\nexport type ToastBarProps = {\n  variant?: 'info' | 'success' | 'error';\n  className?: string;\n  children?: ReactNode;\n  time?: number;\n  isPaused?: boolean;\n  id?: string;\n  onClose?: (id: string) => void;\n  buttonLabel?: string;\n} & Omit<AllHTMLAttributes<HTMLElement>, 'is'>;\n\n/**\n * Shows alerts in a toast component.\n */\nexport function ToastBar({\n  children,\n  className = '',\n  variant = 'info',\n  time = 5,\n  isPaused,\n  id,\n  onClose,\n  buttonLabel = 'Dismiss alert',\n  ...props\n}: ToastBarProps) {\n  const iconName =\n    (variant === 'success' && 'circle-check') ||\n    (variant === 'error' && 'ban') ||\n    'info';\n\n  const sideOpen = keyframes`\n    from {\n      opacity: 0;\n    }\n    to {\n      opacity: 1;\n    }\n  `;\n\n  const progressBar = keyframes`\n    from {\n      width: 0%;\n    }\n\n    to {\n      width: 100%;\n    }\n  `;\n\n  const toastBarAnimation = css`\n    animation: ${sideOpen} 0.5s;\n  `;\n\n  const progressBarAnimation = css`\n    &::after {\n      width: 0%;\n      animation: ${progressBar} ${time}s;\n      animation-fill-mode: forwards;\n      animation-play-state: ${isPaused ? 'paused' : 'running'};\n    }\n  `;\n\n  const uniqueId = useUniqueId();\n  const toastId = id || uniqueId;\n\n  return (\n    <Box\n      className={[\n        `rcx-toastbar rcx-toastbar--${variant} ${className}`,\n        toastBarAnimation,\n      ]}\n      elevation='2nb'\n      borderRadius='x4'\n      {...props}\n    >\n      <div className='rcx-toastbar_inner'>\n        <Icon\n          className={`rcx-toastbar_icon--${variant}`}\n          size='x20'\n          name={iconName}\n        />\n        <div role='alert' className='rcx-toastbar_content'>\n          {children}\n        </div>\n        {onClose && (\n          <div className='rcx-toastbar-close'>\n            <IconButton\n              tiny\n              aria-label={buttonLabel}\n              onClick={() => onClose(toastId)}\n              icon='cross'\n            />\n          </div>\n        )}\n      </div>\n      <Box className={[progressBarAnimation, 'rcx-toastbar_progressbar']} />\n    </Box>\n  );\n}\n","import type { cssFn } from '@rocket.chat/css-in-js';\nimport { css } from '@rocket.chat/css-in-js';\n\nimport { appendClassName } from '../helpers/appendClassName';\nimport type { Falsy } from '../types/Falsy';\nimport { useStyle } from './useStyle';\n\nexport const useArrayLikeClassNameProp = <\n  T extends {\n    className?: string | cssFn | (string | cssFn | Falsy)[];\n  }\n>(\n  props: T\n): T & { className: string } => {\n  const classNames = props.className\n    ? ([] as (string | cssFn | Falsy)[]).concat(props.className)\n    : [];\n\n  const cssFns = classNames.filter(\n    (value): value is cssFn => typeof value === 'function'\n  );\n  const stylesClassName = useStyle(\n    css`\n      ${cssFns}\n    `,\n    props\n  );\n\n  const strings = classNames.filter(\n    (value): value is string => typeof value === 'string'\n  );\n\n  const className = strings.reduce(\n    (className, string) => appendClassName(className, string),\n    stylesClassName || ''\n  );\n\n  return Object.assign(props, { className });\n};\n"],"names":[],"sourceRoot":""}